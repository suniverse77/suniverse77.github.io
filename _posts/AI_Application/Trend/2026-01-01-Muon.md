---
title: "[최적화] Muon Optimizer"
date: 2026-01-01 00:00:00 +/-TTTT
categories: [AI, New]
tags: [3D Vision]
math: true
toc: true
author: sunho
---

이 포스트는 Jia-Bin Huang님의 [This Simple Optimizer Is Revolutionizing How We Train AI [Muon]](https://www.youtube.com/watch?v=bO5nvE289ec&t=928s) 영상을 참고하였습니다.

## 기존 Adam optimizer의 한계

### 1. 메모리 효율성 문제

Adam의 업데이트 공식은 아래와 같으며, 각 파라미터마다 $m$과 $v$ 2개의 변수를 추가로 저장해야 한다.

$$
\theta_{t+1}=\theta_t-\eta\frac{\hat{m}_t}{\sqrt{\hat{v}_t}+\epsilon}
$$

예를 들어 Linear layer에서 $3\times2$ 크기의 가중치 행렬이 있다면, 그와 동일한 크기의 행렬을 저장해야 한다.

$$
W=\begin{bmatrix}
w_{11}&w_{12}\\
w_{21}&w_{22}\\
w_{31}&w_{32}
\end{bmatrix}
~~,~~
M=\begin{bmatrix}
m_{11}&m_{12}\\
m_{21}&m_{22}\\
m_{31}&m_{32}
\end{bmatrix}
~~,~~
V=\begin{bmatrix}
v_{11}&v_{12}\\
v_{21}&v_{22}\\
v_{31}&v_{32}
\end{bmatrix}
$$

결과적으로, Optimizer State가 모델 파라미터 자체보다 2배 더 많은 메모리를 차지하게 된다.

### 2. Low-Rank 문제

Adam은 Vector-based Optimizer이다.
이러한 방식은 가중치 행렬을 행렬로 보지 않고, 단순히 하나의 긴 벡터로 취급하여 각 원소들을 독립적으로 업데이트한다.

예를 들어, $3\times2$ 가중치 행렬을 단순히 6개의 나열된 숫자로 취급한다.

독립적으로 업데이트하기 때문에 각 파라미터가 서로의 상관관계를 무시한 채 개별적인 보폭으로 업데이트되며, 이는 가중치 간의 스케일 불균형 문제로 이어진다.

실제 파라미터 업데이트 과정에서 특정 방향의 특이값만 커져서 모멘텀 행렬이 Low-rank가 되는 경향성이 나타나는데, 이는 소수의 방향만이 업데이트를 주도한다는 의미이다.

## Muon optimizer

Muon은 위와 같은 문제를 모멘텀 행렬 $M$을 직교화함으로써 해결한다.

$M$을 직교화함으로써 아래의 이점을 얻을 수 있다.

- **행렬의 모든 특이값이 1로 정규화**

    모든 방향에 대해 균일한 보폭이 유지되기 때문에 $v$를 별도로 저장할 필요도 없고, 특이값이 작아 학습에서 소외되었던 방향들도 활성화할 수 있다.

- **업데이트 방향이 서로 직교**

    각 파라미터가 중복되지 않는 정보를 학습할 수 있도록 유도할 수 있다.

수학적으로 모멘텀 행렬 $M$을 직교화하는 것은, $M$과 가장 가까운 직교 행렬 $O$를 찾는 것으로 볼 수 있다.

$$
\begin{aligned}
\text{Ortho}(M)=\underset{O}{\arg\min}\lVert O-M\rVert_F\\
\text{subject to}~OO^\top=O^\top O=I~~~~
\end{aligned}
$$

위 최적화 문제의 해 $O$는 SVD를 통해 간단히 구할 수 있다.

$M=USV^\top$라고 할 때, $S$의 모든 특이값을 $1$로 만든 행렬 $O=UV^\top$가 최적해가 된다.

그러나 SVD는 입력 행렬이 클수록 계산량이 기하급수적으로 증가하며, 연산 자체가 하드웨어 가속이 효율적이지 않기 때문에, 실제 학습에서 매 업데이트마다 SVD를 계산하는 것은 어렵다.

### Newton-Schulz Iteration

이 문제를 해결하기 위해 Muon에서는 SVD를 직접 구하는 대신, 행렬 곱만으로 직교 행렬에 수렴시키는 Newton-Schulz iteration을 사용하였다.

행렬 곱은 GPU와 같은 하드웨어 가속에 최적화되어 있기 때문에, SVD보다 연산 속도 측면에서 압도적으로 빠르다.

Muon은 직교화를 위해 홀수 차수 다항식 (Odd Polynomial) 형태의 행렬 함수 $\rho(\cdot)$를 사용한다. 이 함수는 행렬을 입력받아 아래와 같은 연산을 수행한다.

$$
\rho(X)=aX+b(XX^\top)X
$$

위 함수 $\rho(\cdot)$는 행렬 전체를 복잡하게 변형시키는 것처럼 보이지만, 사실 SVD의 관점에서 보면 아래 연산과 동치이다.

$$
\rho(X)=U(aS+bS^3)V^\top
$$

다시 말해, 함수 $\rho(\cdot)$는 회전을 하는 $U$와 $V^\top$는 변화시키지 않고, $S$의 특이값들에만 개별적으로 적용되는 것으로 볼 수 있다.

$$
\rho(X)=U\rho(S)V^\top
$$

<details>
<summary><font color='#0000FF'>공식 유도</font></summary>
<div markdown="1">

1. SVD $X=USV^\top$ 대입

    $$
    \rho(X)=aUSV^\top+b\left(USV^\top (USV^\top)^\top\right)USV^\top
    $$
2. $U$와 $V$의 직교 행렬 성질을 이용해 두 번째 항 정리

    $$
    \left(USV^\top VS^\top U^\top\right)USV^\top
    =USS^\top SV^\top=US^3V^\top
    $$

3. 정리

    $$
    \rho(X)=aUSV^\top+bUS^3V^\top=U(aS+bS^3)V^\top
    $$

---

</div>
</details>
<br>

이러한 원리는 5차 다항식과 같은 모든 홀수 다항식에 적용할 수 있다.

$$
\rho(X)=aX+b(XX^\top)X+c(XX^\top)^2X~~\rightarrow~~
\rho(X)=U(aS+bS^3+cS^5)V^\top
$$

이 함수를 이용하면, SVD를 직접 계산하지 않고도 $a,b,c$에 적절한 값을 선택함으로써 특이값을 $1$에 가깝게 만들 수 있다.

예를 들어 $a=1.5,~b=0.5,~c=0$인 경우, 아래 그림처럼 $\rho(\cdot)$를 적용할수록 출력값이 $1$에 가까워지는 것을 볼 수 있다.

![fig1](new/muon-1.gif){: style="display:block; margin:0 auto; width:70%;"}

이 함수의 개형은 왼쪽 그림과 같다. 또한 계수를 조절함으로써 오른쪽 그림처럼 더 빨리 $1$에 수렴할 수도 있다.

![fig2](new/muon-2.png){: style="display:block; margin:0 auto; width:70%;"}

경험적으로, 특이값을 정확하게 $1$로 수렴하는 것보다 $0.7\sim1.3$과 같은 특정 범위 사이에만 위치시키기만 하면 된다.

![fig4](new/muon-4.png){: style="display:block; margin:0 auto; width:60%;"}

### Muon 알고리즘

Muon의 알고리즘은 아래와 같다. 아래 pseudo code에서 $G$는 그라디언트, $B$는 모멘텀 행렬을 의미한다.

![fig5](new/muon-5.png){: style="display:block; margin:0 auto; width:70%;"}
_[[출처]](https://kellerjordan.github.io/posts/muon/)_

1. 첫 번째 step에서 모멘텀 행렬 $B$를 초기화한다.

    $$B_0=0$$
2. $t=1\dots T$ step마다 아래의 과정을 반복한다.
    
    1. 그라디언트를 계산하고 이를 $G$에 저장한다.

        $$G_t=\nabla_\theta\mathcal{L}_t(\theta_{t-1})$$
    2. 계산한 그라디언트를 이용해 모멘텀 행렬을 업데이트한다.

        $$B_t=\mu B_{t-1}+G_t$$

        이때, $\mu$는 모멘텀 계수를 의미한다.
    3. Newton-Schulze iteration을 5번 반복해 직교 행렬을 얻는다.

        $$O_t=\text{NewtonSchulz5}(B_t)$$
    4. 직교 행렬을 이용해 최종적으로 파라미터를 업데이트한다.

        $$\theta_t=\theta_{t-1}-\eta O_t$$
